{
  "_args": [
    [
      {
        "raw": "supersede@1.x",
        "scope": null,
        "escapedName": "supersede",
        "name": "supersede",
        "rawSpec": "1.x",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/jbrown/Sites/10-apps-in-10-weeks/react/react-website/node_modules/interrupt"
    ]
  ],
  "_from": "supersede@>=1.0.0 <2.0.0",
  "_id": "supersede@1.0.3",
  "_inCache": true,
  "_location": "/supersede",
  "_nodeVersion": "4.8.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/supersede-1.0.3.tgz_1491498235508_0.3070664496626705"
  },
  "_npmUser": {
    "name": "bigeasy",
    "email": "alan@prettyrobots.com"
  },
  "_npmVersion": "4.4.4",
  "_phantomChildren": {},
  "_requested": {
    "raw": "supersede@1.x",
    "scope": null,
    "escapedName": "supersede",
    "name": "supersede",
    "rawSpec": "1.x",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/interrupt"
  ],
  "_resolved": "https://registry.npmjs.org/supersede/-/supersede-1.0.3.tgz",
  "_shasum": "aac35b89df91777c15d3845b0b40d47398ec9b5f",
  "_shrinkwrap": null,
  "_spec": "supersede@1.x",
  "_where": "/Users/jbrown/Sites/10-apps-in-10-weeks/react/react-website/node_modules/interrupt",
  "author": {
    "name": "Alan Gutierrez",
    "email": "alan@prettyrobots.com"
  },
  "bugs": {
    "url": "https://github.com/bigeasy/supersede/issues"
  },
  "dependencies": {},
  "description": "A path based set where the most specific path wins.",
  "devDependencies": {
    "proof": "3.0.x"
  },
  "directories": {},
  "dist": {
    "shasum": "aac35b89df91777c15d3845b0b40d47398ec9b5f",
    "tarball": "https://registry.npmjs.org/supersede/-/supersede-1.0.3.tgz"
  },
  "gitHead": "5a8cc941807a6b58a1501da1e8be1d6089150ccb",
  "homepage": "https://bigeasy.github.io/supersede",
  "keywords": [
    "set",
    "path",
    "tree",
    "levels"
  ],
  "license": "MIT",
  "main": "supersede",
  "maintainers": [
    {
      "name": "bigeasy",
      "email": "alan@prettyrobots.com"
    }
  ],
  "name": "supersede",
  "optionalDependencies": {},
  "readme": "A path based set where the most specific path wins.\n\n### Synopsis\n\n```javascript\nvar assert = require('assert')\nvar supersede = require('supersede')\n\n// create a set\nvar set = new Supersede\n\n// set a value keyed to a path of depth 2.\nset.set('.hello.world'.split('.'), 'hello, world')\n\n// get the value\nassert.equal(set.get('.hello.world'), 'hello, world')\n\n// get a non-existant value\nassert.equal(set.get('.hello.earth'), null)\n\n// set a value keyed to a path of depth 1.\nassert.equal(set.get('.hello'), 'hello, you')\n\n// parent value is used\nassert.equal(set.get('.hello.earth'), 'hello, earth')\n\n// the most specific path wins\nassert.equal(set.get('.hello.world'), 'hello, world')\n\n// gather along a path\nassert.deepEqual(set.gather('.hello.world'), [ 'hello, earth', 'hello, world' ])\n```\n\n### Usage\n\nKeys are generated by calling `split('.')` on a path string that begins with a\ndot `'.'` where path steps are dot `'.'` delimited.\n\n```javascript\nvar assert = require('assert')\n\nvar rootPath = '.'.split('.')\nvar otherPath = '.hello.world'.split('.')\n\nassert.deepEqual(rootPath, [ '', '' ])\nassert.deepEqual(otherPath, [ '', 'hello', 'world' ])\n```\n\nSupersede does not perform this split itself because if you're really in a\nhurry you might want to save the generated arrays for later use, or type out the\nkey as an array literal.\n\n#### `supersede = new Supersede`\n\nCreate an empty set.\n\n#### `supersede.set(path, value)`\n\nSets a key to the given value overriding any key.\n\n#### `supersede.gather(path, value)`\n\nGathers the values along the given path into an array. If there are no values\nalong the path an empty array is returned.\n\n#### `supersede.remove(path)`\n\nRemoves the value of the node specified by the given path.\n\n### Diary\n\nThe star `'*'` here is special and needs to be used carefully. Using it to\nremove all might not be the best.\n\nWhat if we want to register a listener, so we place a `'*'` in the tree itself?\nThen we can search a path where we look for everything that is the given step or\na star, but now we are getting into some recursive pattern matching. Do we\nreally want to match `'*'` star?\n\n\n```javascript\nsignal.on('system.web.rost', handler1)\nsignal.on('system.*.error', handler2)\n\nsignal.on('system.web.logger.info', logger.info)\n```\n\nWhat is going to be useful? So much thought to put into late binding.\n\nThe only place that is useful is in `gather`, so I can make a new function that\nrespsects that, but it would be slightly more expensive than `gather`, but only\nslightly more. It will not be universal. It can only be for `'*'`.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/bigeasy/supersede.git"
  },
  "scripts": {
    "test": "proof platform win32 && proof test */*/*.t.* || t/test"
  },
  "version": "1.0.3"
}
