{
  "_args": [
    [
      {
        "raw": "cadence@1.x",
        "scope": null,
        "escapedName": "cadence",
        "name": "cadence",
        "rawSpec": "1.x",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/jbrown/Sites/10-apps-in-10-weeks/react/react-website/node_modules/eject"
    ]
  ],
  "_from": "cadence@>=1.0.0 <2.0.0",
  "_id": "cadence@1.0.1",
  "_inCache": true,
  "_location": "/cadence",
  "_nodeVersion": "4.4.4",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/cadence-1.0.1.tgz_1465511745190_0.8069736801553518"
  },
  "_npmUser": {
    "name": "bigeasy",
    "email": "alan@prettyrobots.com"
  },
  "_npmVersion": "2.15.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "cadence@1.x",
    "scope": null,
    "escapedName": "cadence",
    "name": "cadence",
    "rawSpec": "1.x",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/eject"
  ],
  "_resolved": "https://registry.npmjs.org/cadence/-/cadence-1.0.1.tgz",
  "_shasum": "0d5b8b3c369b24ffa252bc64d91c0f7bece81950",
  "_shrinkwrap": null,
  "_spec": "cadence@1.x",
  "_where": "/Users/jbrown/Sites/10-apps-in-10-weeks/react/react-website/node_modules/eject",
  "author": {
    "name": "Alan Gutierrez",
    "email": "alan@prettyrobots.com"
  },
  "bugs": {
    "url": "http://bigeasy.github.com/cadence"
  },
  "dependencies": {},
  "description": "A Swiss Army asynchronous control flow function for highly-parallel control flows.",
  "devDependencies": {
    "proof": "1.x",
    "uglify-js": "~1.3"
  },
  "directories": {},
  "dist": {
    "shasum": "0d5b8b3c369b24ffa252bc64d91c0f7bece81950",
    "tarball": "https://registry.npmjs.org/cadence/-/cadence-1.0.1.tgz"
  },
  "gitHead": "04d907210e3141f490492232649083466c50e2d3",
  "homepage": "http://bigeasy.github.com/cadence",
  "keywords": [
    "async",
    "asynchronous",
    "control",
    "flow",
    "loop",
    "micro-js",
    "step",
    "callback"
  ],
  "license": "MIT",
  "main": "cadence",
  "maintainers": [
    {
      "name": "bigeasy",
      "email": "alan@prettyrobots.com"
    }
  ],
  "name": "cadence",
  "optionalDependencies": {},
  "readme": "Cadence is a control-flow library for error-first callback style of asynchronous\nprogramming. Cadence is my solution to the problem of the [Pyramid of\nDoom](http://tritarget.org/blog/2012/11/28/the-pyramid-of-doom-a-javascript-style-trap/).\n\nCadence is one step after another, with robust **try/catch** error handling for\nasynchronous errors, **finalizers** for clean up, **nested** asynchronous\n**loops** with **break and continue**, and **tail-recursion elimination** to\nyou'll never blow your stack looping.\n\nCadence does all this in **pure-Javascript** with **no transpilers** and without\nES6+ features. Cadence is classic Javascript. Cadence is tiny. Cadence is fast.\n\n### Cadence In a Nutshell\n\nCadence runs a series of functions asynchronously, using the results of one\nfunction as the arguments for the next. (This was inspired by Tim Caswell's\n[step](https://github.com/creationix/step) module.)\n\nWe call the series of functions a **cadence**. We call an individual function in\na cadence a **step**.\n\nWe create **cadences** using the universal builder method `async`. We also use\n`async` to create **callbacks** inside the **steps**. The `async` function is a\nuniversal builder because we use it to create both **cadences** and\n**calbacks**.\n\n```javascript\n// `cat`: write a file to a stream.\nvar cat = cadence(function (async, file, stream) {\n                         // ^^^^^ our universal builder function.\n    async(function () {\n //       ^^^^^^^^ create a cadence of one or more steps.\n        fs.readFile(file, 'utf8', async())\n                               // ^^^^^^^ create a callback.\n    }, function (body) {\n              // ^^^^ the result is passed to the next step.\n        stream.write(body)\n\n    })\n})\n\ncat(__filename, process.stdout, function (error) {\n                                       // ^^^^^ any error, anywhere inside `cat` is propagated out\n    if (error) throw error\n})\n```\n\nErrors get propagated up and out of the function to the caller. The next\n**step** does not receive an error argument and does not have to check the error\nargument.\n\nThis menas that your code does not need to be littered with `if (error)\ncallback(error)` branches that are difficult to reach in your tests. This is a\nmajor benefit of Cadence. Your asynchronous code is reduced to the happy path.\n\nHere an example of a function that will return `true` if a regex matches the\ncontents of a file.\n\n```javascript\nvar cadence = require('cadence'), fs = require('fs')\n\nvar grep = cadence(function (async, file, regex) {\n\n    async(function () {\n\n        fs.readFile(file, 'utf8', async())\n\n    }, function (body) {\n\n        return regex.test(body)\n\n    })\n\n})\n\ngrep(__filename, /readFile/, function (error, deleted) {\n    if (error) console.log(error)\n    else if (found) console.log('found readFile')\n    else console.log('did not find readFile')\n})\n```\n\nThe Cadence function above returns a value to the user's callback. The result of\nthe function is the result of **cadence** defined in the function. The last\n**step** of a **cadence** is the result of a **cadence**. The result of a\n**step** is either results of any **callbacks** or nested **cadences**, or else\na value returned using `return`.\n\n*TK: Stopped here. Keep rewriting.*\n\n### Major Benefit: Try/Catch and Finalize\n\nCadence implements an asynchronous try/catch block that propagates error-first\ncallback errors and converts thrown exceptions into error-first callback errors.\nWhen uses consistently, you end up with an asynchronous call stack.\n\n```javascript\nvar cadence = require('cadence'), fs = require('fs')\n\nvar deleteIf = cadence(function (async, file) {\n\n    async([function () {\n\n        fs.unlink(file, async())        // try\n\n    }, /^ENOENT$/, function () {\n\n        return [ async.break, false ]   // catch ENOENT\n\n    }], function () {\n\n        return [ true ]                 // deleted\n\n    })\n\n})\n\ndeleteIf('junk.txt', function (error, deleted) {\n    if (error) console.log(error)\n    console.log('junk.txt: was deleted ' + deleted)\n})\n```\n\nIn the above we use a catch block to catch an `ENOENT` error and return `false`,\notherwise return `true`. If an error other than `ENOENT` is raised, the the\nerror will be passed as the first argument. The try/catch block is the try\n**step** and the catch **step** paired together in an array. You can see how we\ncan return `async.break` from any **step** to leave the **cadence** early.\n\nUntil you use it, it is hard desrcibe how much easier it is to program\nasynchronous Node.js when you have this asynchronous stack. You're no longer\ndealing with mystery errors merging from a univeral error handler, your error\nhanding can have context; you know the nature of the error, because you know the\nfunction you called that raised the error.\n\n### What Cadence Can Do for You\n\n*Ed: Older benefit list, all still true, but needs tidy.*\n\nCadence is pure-JavaScript library control-flow library with no transpilers. The\nCadence kernel is designed to JIT compile and get out of the way.\n\nCadence can express all manner of asynchronous operations, including:\n\n * serial asynchronous operations, of course\n * parallel asynchronous operations, naturally\n * `while` loops, `do..while` loops, or `counted` loops\n * each loops that can either map or reduce an array\n * `break` from labeled loops or `continue` them, even up out of nested loops to\n   an outer loop\n * asynchronous try and catch exception handling\n * asynchronous finalizers for clean up\n\nCadence has features that you don't know you wantâ€¦ yet:\n\n * Have you been bitten by a stack overflow yet? Cadence runs your code in a\n   trampoline, so that asynchronous functions that callback in the same tick do\n   not add a stack frame.\n * Do you have a strategy to test every one of those `if (error)` branches?\n   Cadence handles your errors for you and propagates them up and out to the\n   user.\n * What about cleaning up after an error? You can't just `if (error)\n   callback(error)` if you have files open or databases on the line. Cadence has\n   try/catch blocks and finalizers.\n * Who is `this`? With Cadence `this` is consistent all throughout a function\n   body. You don't have to `bind(this)` or `var self = this` with Cadence.\n\nYou can use Cadence in the browser too. It is not Node.js dependent and it\nminzips to ~2.31k. Great for use with Browserfy.\n\n## Cadence Step by Step\n\nCadence exports a single function which by convention is named `cadence`.\n\nThe `cadence` function is a function builder. It creates an asynchronous\nfunction that expects an error-first callback as its final argument, the\nasynchronous style used in many of the modules that ship with Node.js.\n\n```javascript\n// import cadence\nvar cadence = require('cadence'), fs = require('fs')\n\n// create an error-first callback style asynchronous function\nvar find = cadence(function (async, path, filter) {\n\n    async(function () {\n\n        fs.readdir(path, async())\n\n    }, function (list) {\n\n        return list.some(filter)\n\n    })\n})\n\n// call the function with function arguments and an error-first callback\nfind(__dirname, isJavaScript, function (error, found) {\n\n    if (error) {\n        console.log(error)\n    } else if (found) {\n        console.log(__dirname + ' contains a JavaScript file.')\n    }\n\n})\n\nfunction isJavaScript (file) {\n    return /\\.js$/.test(file)\n}\n```\n\nTo learn more about Cadence, let's look closer at the `find` function.\n\n### Function Body\n\nWe create the `find` function by invoking `cadence` with a single argument which\nis the function body for `find`.  The `cadence` function will build a function\nthat, when invoked, will call the function body.\n\n```javascript\nvar find = cadence(function (async, path, filter) {\n                // ^^^^^^^^ function body\n    async(function (  {\n\n        fs.readdir(path, async())\n\n    }, function (list) {\n\n        return list.some(filter)\n\n    })\n\n})\n```\n\n### The `async` Function\n\nThe first argument to the body is the universal builder function which by\nconvention is named `async`. It is named `async` because anywhere you see it,\nyou know that something asynchronous is going on.\n\n```javascript\nvar find = cadence(function (async, path, filter) {\n                          // ^^^^^ universal asynchronous builder function.\n    async(function () {\n // ^^^^^ it creates both cadences...\n        fs.readdir(path, async())\n                      // ^^^^^ ...and callbacks\n    }, function (list) {\n\n        return [ list.some(filter) ]\n\n    })\n\n})\n```\n\n### Steps and Cadences\n\nWhen you invoke the `async` function with one or more functions, you create a\n**cadence**. Each function is a **step** in the cadence.\n\n```javascript\nvar find = cadence(function (async, path, filter) {\n\n    async(function () { // <- let's create a cadence\n       // ^^^^^^^^ step one\n        fs.readdir(path, async())\n\n    }, function (list) {\n    // ^^^^^^^^ step two\n        return [ list.some(filter) ]\n\n    })\n\n})\n```\n\n### Cadence Argument Progression\n\nThe results of one **step** in a **cadence** become the arguments of the next **step**.\n\n```javascript\nvar find = cadence(function (async, path, filter) {\n\n    async(function () {\n\n        fs.readdir(path, async())\n                      // ^^^^^ create a callback whose return value\n    }, function (list) {\n              // ^^^^ is the argument of the next step\n        return [ list.some(filter) ]\n\n    })\n\n})\n```\n\nThe `async` function is used to create a callback that is given to `fs.readdir`.\nThe next **step** is called with the result of the previous **step**, but\nwithout the error. The error is shifted off the arguments so that the next\n**step** receives no errors, only results. There is no error for the **step** to\ncheck. There is no need for an `if (error)` at every **step**.\n\n### Error Propagation\n\nIf an error does occur, it propagates out to the user. No matter how deeply\nnested your **cadences**, an error will stop the **cadence** and return the\nerror to the user.\n\n```javascript\nvar cadence = require('cadence'), fs = require('fs')\n\nvar find = cadence(function (async, path, filter) {\n\n    async(function () {\n\n        fs.readdir(path, async())\n                      // ^^^^^ an error returned to any callback...\n    }, function (list) {\n\n        return [ list.some(filter) ]\n\n    })\n\n})\n\nfind(__dirname, isJavaScript, function (error, found) {\n                                     // ^^^^^ ...propagates out to here.\n    if (error) {\n        console.log(error)\n    } else if (found) {\n        console.log(__dirname + ' contains a JavaScript file.')\n    }\n\n})\n\nfunction isJavaScript (file) {\n    return /\\.js$/.test(file)\n}\n```\n\n### Synchronous versus Asynchronous Steps\n\nIn our `find` function, we can see that there are two ways for a **step** to\nproduce a result.\n\nWhen the `async()` function is called, a **callback** is created. The results\npassed to the **callback** are the arguments given to the step. Alternatively,\nthe **step** can use `return` to retun an array of results where are used as the\nargument to the next **step**.\n\n```javascript\nvar find = cadence(function (async, path, filter) {\n\n    async(function () {\n\n        fs.readdir(path, async())\n                      // ^^^^^ create a callback whose return value\n    }, function (list) {\n              // ^^^^ is the argument of the next step\n        return [ list.some(filter) ]\n\n    })\n\n})\n```\n\n### Cadence Return Values\n\nThe results of the final **step** in a **cadence** are the results of the\n**cadence**. In the case, the final **step** is a synchronous `return`, but the\nfinal **step** could as easily be the result of another asynchronous call.\n\n```javascript\nvar find = cadence(function (async, path, filter) {\n\n    async(function () {\n\n        fs.readdir(path, async())\n\n    }, function (list) {\n\n        return [ list.some(filter) ]\n     // ^^^^^^ result of final step is the result of the cadence.\n    })\n\n})\n```\n\nThe results of all the **cadences** and **callbacks** in the function body are\nthe results of the function generated by `cadence`.\n\n```javascript\nvar cadence = require('cadence'), fs = require('fs')\n\nvar find = cadence(function (async, path, filter) {\n\n    async(function () {\n\n        fs.readdir(path, async())\n\n    }, function (list) {\n\n        return [ list.some(filter) ]\n     // ^^^^^^ result of the only cadence...\n    })\n\n})\n\nfunction isJavaScript (file) {\n    return /\\.js$/.test(file)\n}\n\nfind(__dirname, isJavaScript, function (error, found) {\n                                            // ^^^^^ ...is the result of function.\n    if (error) {\n        console.log(error)\n    } else if (found) {\n        console.log(__dirname + ' contains a JavaScript file.')\n    }\n\n})\n```\n\n## Cadence In Detail\n\n*Ed: Hate to be a bum, but there needs to be some transition from the above,\nwhich I believe does a good job, to the below, which allows us to look at finer\npoints.*\n\nNow let's look at Cadence in some more detail.\n\nWe'll go over some of what we covered in Cadence Step by Step, but with\nattention to detail using contrived examples that illustrate the point.\n\n*Note: It is difficult to both illustrate the every edge case in the use of\nCadence and come up with real world examples that are concise. We're going to\nshow some trival functions that do frivolous things, but show you exactly how\nCadence works.*\n\nWe now get the gist of how Cadence uses **cadences** composed of **steps** to\ncreate asynchronous control flows. Let's start looking at the details of control\nflows and work toward advanced Cadence features.\n\n### Our Friend Echo\n\nIn our detailed examples we are going to use a function called echo which will\ninvoke the callback with the argument given. We're also going to assume that we\nhave `ok`, `equal` and `deepEqual` to assert what we believe to be true.\n\n```javascript\nvar ok = require('assert').ok\nvar equal = require('assert').equal\nvar deepEqual = require('assert').deepEqual\n\nfunction echo (value, callback) {\n    setImmediate(callback, null, value)\n}\n```\n\n\n### Function Bodies with No Cadence\n\nWhen you invoke `async` with no arguments, it builds a simple error first\n**callback** function. Cadence will receive the results given to the\n**callback** on your behalf and do the right thing.\n\n```javascript\nvar minimal = cadence(function (async) {\n    echo(1, async())\n})\n\nminimal(function (error, value) {\n    equal(value, 1, 'called back')\n})\n```\n\nIn this case, we did nothing but call an asynchronous function giving it an\nerror-frist callback. It was the last thing we did so it became the result of\nthe generated function `minimal`.\n\nSimilarly, you can return a value from a Cadence function body using `return`.\n\n```javascript\nvar minimal = cadence(function (async) {\n    return [ 1 ]\n})\n\nminimal(function (error, value) {\n    equal(value, 1, 'called back')\n})\n```\n\n### More on Funtion Body Return Values\n\nThe results of all the **cadences** and **callbacks** in the function body are\nthe results of the function generated by `cadence`.\n\n```javascript\nvar resulting = cadence(function (async) {\n    async(function () {\n        echo(1, async())\n    })\n})\n\nresulting(function (error, value) {\n    equal(value, 2, 'incremented')\n})\n```\n\n### Creating Cadences\n\n*Ed: This is duplicated, and dumb. Really, let's use the examples above to\nintroduce details, and as a later project make an all baby-steps walk through,\nor maybe a more rule by rule walk though. Cadence Rule: A Function Body is a\nSingle Step, Cadence Rule: Asynchronous Trumps Synchronous, Cadence Rule: Always\nPoke a Hamster.*\n\nWhen you invoke `async` with one or more functions, you build a **cadence**.\nEach function in the cadence is called a **step**.\n\n```javascript\nvar stepper = cadence(function (async) {\n\n    async(function () {\n       // ^^^^^^^^ one or more functions creates a cadence.\n        echo(1, async())\n\n    }, function (value) {\n\n        equal(value, 1, 'stepped')\n\n        echo(value, async())\n                 // ^^^^^ this will be the result of the cadence and the function.\n    })\n})\n\nstepper(function (error, value) {\n\n    equal(value, 1, 'called back')\n\n})\n```\n\n### More on Propagating Errors\n\nAny error or exception that occurs in the function body is propagated to the\ncaller by default.\n\n```javascript\nfunction brokenEcho (value, callback) {\n    callback(new Error('out of service'))\n}\n\nvar stepper = cadence(function (async) {\n\n    async(function () {\n\n        brokenEcho(1, async())\n                   // ^^^^^ this callback will propagate the error.\n\n    }, function (value) { // <- the next step will not be called because of the error.\n\n        brokenEcho(value, async())\n\n    })\n})\n\nstepper(function (error, value) {\n               // ^^^^^ our error, propagated.\n    equal(error.message, 'out of service', 'errors propagate')\n\n})\n```\n\n### Propagating Exceptions\n\nExceptions are also propagated. You can throw an exception anywhere in the\nfunction body and it will propagate out to the user as the error-first error.\n\n```javascript\nvar stepper = cadence(function (async) {\n\n    async(function () {\n\n        throw new Error('out of service')\n\n    }, function () { // <- will not be called.\n\n        echo(1, async())\n\n    })\n})\n\nstepper(function (error, value) {\n               // ^^^^^ our exception, propagated.\n    equal(error.message, 'out of service', 'exceptions propagate')\n\n})\n```\n\n### Function Body Arguments\n\nThe first argument to the function body is always the `async` function. The rest\nof the arguments are the parameters passed to the `cadence` generated function.\n\n```javascript\nvar arguable = cadence(function (async, value) {\n                                     // ^^^^^ from the caller.\n    async(value, async())\n\n})\n\narguable(1, function (error, value) {\n      // ^ `value` parameter in `arguable`.\n    equal(value, 1, 'argument passed')\n\n})\n```\n\n### Variadic Functions\n\nBecause the error-first callback conventions dictate that the error-first `callback` is the\nlast argument, you might wonder why `async` is the first.\n\nWe put the `async` as the first argument, not the last, because Cadence is\nnothing without its `async` function. We're (almost) always going to need it so\nit will always be passed into the function body as the first argument.\n\nBest of all, putting the `async` function at the head to make it easier to\nimplement variadic functions. No messy `var callback = vargs.pop()`.\n\n```javascript\nvar argumentCounter = cadence(function (async) {\n\n    var vargs = Array.prototype.slice.call(arguments, 1)\n    async(vargs.length, async())\n\n})\n\narguable('a', 'b', 'c', function (error, count) {\n\n    equal(count, 3, 'three arguments')\n\n})\n```\n\nA `cadence` generated function always expects a callback. There is\nno concept of optional callbacks.\n\n### Multiple Callback Arguments\n\nBecause error-first callbacks can receive multiple arguments, **steps** can\nreceive multiple arguments and a **cadence** can return multiple results.\n\nBecause a **cadence** can return multiple arguments a function body can also\nreturn multiple arguments.\n\n```javascript\nfunction echo2 (one, two, callback) {\n    setImmediate(callback, null, one, two)\n}\n\nvar multi = cadence(function (async)\n    async(function () {\n\n        echo2('a', 'b', async())            // <- multiple results\n\n    }, function (first, second) {           // <- multiple arguments\n\n        assert(first, 'a', 'one of two in step')\n        assert(second, 'a', 'two of two in step')\n\n        echo2(first, second, async())       // <- multiple results returned\n\n    })\n})\n\nmulti(function (error, first, second) {     // <- multiple results received\n    if (error) throw error\n    assert(first, 'a', 'one of two results')\n    assert(second, 'a', 'two of two results')\n})\n```\n\n### Synchronous Steps Using `return`\n\nSometimes **steps** do not need to call asynchronous functions. In that case we can\nsimply use `return` to pass a value to the next **step**, but only if the value\nis not an array.\n\n```javascript\nvar synchronous = cadence(function (async) {\n\n    async(function () {\n\n        return 1                        // <- single value returned\n\n    }, function (value) {               // <- single value received\n\n        equal(value, 1, 'return number')\n\n        echo(value, async())\n\n    })\n\n})\n\nsynchronous(function (error, value) {\n    if (error) throw error\n    equal(value, 1, 'sync worked')\n})\n```\n\n### Returning Multiple Arguments from a Step\n\nWhen we want to synchronously return multiple values, we return an array of\narguments. The elements in the array are used as the arguments to the next\nfunction, much like calling `apply`.\n\n```javascript\nvar synchronous = cadence(function (async) {\n\n    async(function () {\n\n        return [ 1, 2 ]                 // <- two values returned\n\n    }, function (first, second) {       // <- two values received\n\n        equal(first, 1, 'one of two')\n        equal(second, 2, 'two of two')\n\n        echo(first + second, async())\n\n    })\n\n})\n\nsynchronous(function (error, value) {\n\n    equal(value, 3, 'multiple argument sync worked')\n\n})\n```\n\n### Returning an Array from a Step\n\nIf you want to synchronously pass an array to the next **step**, you cannot\nsimply return the array, because the array elements will be used as the\narguments for the next **step**.\n\nTo synchronously pass an array to the next step, you return an array of\narguments that contians the array.\n\n```javascript\nvar synchronous = cadence(function (async) {\n\n    async(function () {\n\n        var values = [ 1, 2, 3 ]\n\n        return [ values ]           // <- array returned\n\n    }, function (values) {          // <- array received\n\n        ok(Array.isArray(values), 'is an array')\n        equal(values.length, 3, 'is an array of three elements')\n\n        echo(values.reduce(function (sum, value) { return sum + value }), async())\n\n    })\n\n})\n\nsynchronous(function (error, value) {\n\n    equal(value, 6, 'array as a synchronous worked')\n\n})\n```\n\n### Asynchronous Trumps Synchronous\n\nAsynchronous trumps synchronous. If you create a callback or a **cadence** using\n`async` inside a **step**, then the return value of the **step** is ignored.\n\n```javascript\nvar trump = cadence(function (async) {\n\n    async(function () {\n\n        echo(2, async())        // <- callback created\n\n        return 1                // <- value returned\n\n    }, function (value) {       // <- callback value received, return value ignored\n\n        equal(value, 2, 'async trumps sync')\n        echo(value, async())\n\n    })\n\n})\n\ntrump(function (error, value) {\n\n    equal(value, 2, 'async wins')\n\n})\n```\n\n### Cadences within Cadences\n\nYou can create a **cadence** in a **cadence** and you will. You can create a\n**cadence** in any **step**. The result of the **cadence** is passed as an\nargument to the next **step**.\n\nA **cadence** is an asynchronous operation that will trump a return values.\n\n```javascript\nvar sync = cadence(function (async) {\n\n    async(function () {\n\n        async(function () { // <- a cadence in a step.\n\n            echo(1, async())\n\n        }, function (value) {\n\n            echo(value + 1, async())\n                         // ^^^^^ last callback of last step.\n        })\n\n    }, function (value) {\n\n        equal(value, 2, 'sub-cadence output')\n        echo(value, async())\n\n    })\n\n})\n\nsync(function (error, value) {\n\n    equal(value, 2, 'cadences within cadences')\n\n})\n```\n\nReturn values from **cadences** propagate up. Nest them as you see fit.\n\n```javascript\nvar sync = cadence(function (async) {\n\n    async(function () {\n\n        async(function () {\n\n            echo(1, async())\n\n        }, function (value) {\n\n            async(function () { // <- one step cadence, three cadences deep.\n\n                echo(value + 1, async())\n                             // ^^^^^ this result goes up two cadences.\n            })\n\n        })\n\n    }, function (value) {\n\n        equal(value, 2, 'sub-cadence output')\n        echo(value, async())\n\n    })\n\n})\n\nsync(function (error, value) {\n\n    equal(value, 2, 'cadences within cadences')\n\n})\n```\n\n### Cadences within Cadences: Practical Application\n\nYou will use **cadences** in **steps** in **cadences** to manage your scope. It\nis a common construct.\n\nIn Cadence an indent means something. It means a new scope. You stay indented\nwhen you have variables that need to be in scope for multiple asynchronous\noperations. When the variables are no longer needed, the indent ends.\n\nThe following looks for the Unix execuable [magic\nnumber](http://en.wikipedia.org/wiki/Shebang_%28Unix%29#Magic_number).\n\n```javascript\n#!/usr/bin/env node\n\n// `sip`: sip the first `count` bytes of a file.\nvar sip = cadence(function (async, file, count) {\n\n    async(function () {\n\n        fs.open(file, async())\n\n    }, function (fd) {\n              // ^^ we need to use this for more than one step.\n        async(function () {\n\n            var buffer = new Buffer(count)\n            fs.read(buffer, 0, buffer.length, 0, async())\n\n        }, function (bytesRead, buffer) {\n                  // ^^^^^^^^^  ^^^^^^  must close the file descriptor  before we can return these.\n            async(function () {\n\n                fs.close(fd, async())\n\n            }, function () {\n\n                return buffer.slice(0, bytesRead) // <- we're three cadences deep\n\n            })\n\n        })\n\n    })\n\n})\n\n// sip two bytes of a file and look for the executable magic number.\nsip(__filename, 2, function (error, value) {\n\n    if (value.length == 2 &amp;&amp; value[0] == 0x23 &amp;&amp; value[1] == 0x21) {\n        console.log('I have a shebang line!')\n    }\n\n})\n```\n\n### Fallthrough when a Step Returns Nothing\n\nIf you create a **step** that neither returns a value nor creates an\nasynchronous operation using the `async` function, then the results of that\n**step** are its arguments.\n\nPut another way, if a **step** does not produce any results, then the **next**\nstep receives the results of the last **step** to produce results.\n\n```javascript\nvar fallthrough = cadence(function (async) {\n\n    async(function () {\n\n        echo(1, async())\n\n    }, function (value) {\n\n        equal(value, 1, 'callback value')\n\n        console.log(value)\n\n    }, function (value) {\n\n        equal(value, 1, 'callback value from step before last')\n\n        return value + 1\n\n    }, function (value) {\n\n        equal(value, 2, 'returned value')\n\n        console.log(value)\n\n    }, function (value) {\n\n        equal(value, 2, 'returned value from step before last')\n                // <- no return or `async`, outcome is also a fall through.\n    })\n\n})\n\nfallthrough(function (error, value) {\n\n    equal(value, 2, 'fell through')\n\n})\n\n```\n\n### Parallel versus Serial\n\nThe **steps** in a **cadence** run in *serial*, one step after another.\n\nThe asynchronous operations in a **step** run in *parallel*. An asynchronous\noperation in a **step** is a **cadence** or a function that invokes a\n**callback**.\n\nIf you see `async` in a **step**, something asynchronous is going on. If you see\nmore than one `async` in a **step**, something parallel is going on.\n\nMultiple the results of multiple asynchronous operations in a **step** are\ngathered and passed as arguments to the next **step**. The next **step** is not\ncalled until all the asynchronous operations finish.\n\n```javascript\nvar parallel = cadence(functions (async) {\n\n    async(function () {\n\n        echo(1, async())            // <- first async call.\n        echo(2, async())            // <- second async call.\n\n    }, function (first, second) {   // <- called when both echoes complete.\n\n        return [ first, second ]\n\n    })\n})\n\nparallel(function (error, first, second) {\n\n    assert(first, 1, 'one of two returned')\n    assert(second, 1, 'two of two returned')\n\n})\n```\n\nThe next **step** is called with the results of the mulitple **callbacks** or\n**cadences**. The results are returned in the order in which their **callback**\nor **cadence** was declared.\n\n```javascript\nvar parallel = cadence(functions (async) {\n\n    async(function () {\n\n        var first = async()         // <- first callback.\n        var second = async()        // <- second callback.\n\n        second(null, 1)             // <- call second first, and right now.\n        echo(1, first)              // <- call first on next tick.\n\n    }, function (first, second) {\n\n        assert(first, 1, 'first order of callback do not matter')\n        assert(second, 2, 'second order of callback do not matter')\n\n        return [ first, second ]\n\n    })\n})\n\nparallel(function (error, first, second) {\n\n    assert(first, 1, 'one of two returned')\n    assert(second, 1, 'two of two returned')\n\n})\n```\n\n*TK: But, parallel has changed.*\n\n### Practical Application: Parallels as Funnels\n\n*TK: Example of opening file and database.*\n\n### Gathered Parallels\n\nWith gathered parrallels, instead of passing the asynchronous results into the\nnext **step** as individual arguments, they are passed as an array of arguments.\n\nThe asynchronous results of the **step** are gathered in an array and the array\nis passed to the next **step**. The next **step** receives only one argument, an\narray containing all the asynchronous results of the previous **step**.\n\nWe indicate that we want gathered results by placing an empty array after the\n**step** whose results we want to gather.\n\n```javascript\nvar parallel = cadence(functions (async) {\n    var array = [ 1, 2, 3, 4, 5 ]\n\n    async(function () {\n\n        for (var i = 1; i < array.length; i++) {\n            echo(array[i] + array[i - 1], async())\n        }\n\n        echo(1, async())            // <- first async call.\n        echo(2, async())            // <- second async call.\n\n    }, [], function (array) {       // <- called when both echoes complete.\n\n        equal(array[0], 1, 'first element')\n        equal(array[1], 2, 'second selement')\n\n        return array.length\n\n    })\n})\n\nparallel(function (error, length) {\n\n    assert(length, 2, 'length of array')\n\n})\n```\n\nYou can probably imagine how when combinded with a loop, you could do a\nreasonable amount of work in parallel.\n\n```javascript\nvar parallel = cadence(functions (async) {\n    var array = [ 1, 2, 3, 4, 5 ]\n\n    async(function () {\n\n        for (var i = 1; i < array.length; i++) {\n            echo(array[i] + array[i - 1], async())\n        }\n\n    }, [], function (array) {       // <- called when both echoes complete.\n\n        deepEqual(array, [ 3, 5, 7, 9 ], 'summed')\n\n        return [ array ]\n\n    })\n})\n\nparallel(function (error, array) {\n\n    deepEqual(array, [ 3, 5, 7, 9 ], 'summed returned')\n\n})\n```\n\nHowever, it is much better, I believe to do parallel work using a work queue,\nwhich is why I've created [Turnstile](https://github.com/bigeasy/turnstile) and\n[Reactor](https://github.com/bigeasy/reactor).\n\n## Practical Example of Parallel Gathering: Directory Listings\n\n**TK**\n\n**TK: Although there are mechanisms for homogeneous parallel operations, that sort of\nparallelism is best obtained at the serivce level. Instead of having a\nhighly-parallel directory listing in your web server, let your web server serve\nmany directory listings in parallel, each being worked through in serial. You\nwill get similar performance, but with a lot less complexity.*\n\nThe complexity comes in the error handling. If you can't read one file in a\ndirectory, you probably can't read any of them. Now you have an array of errors\ninstead of an array of file statistics.\n\nWhat we are discussing here are *heterogeneous* parallel operations, and they are\ngenerally useful and easy to reason about. The make a lot of sense when you\nneed to to create funnel, performing multiple heterogeneous asynchronous\noperations needed for the next **step**.\n\nThe following is a contrived initialization example.\n\n```javascript\nvar initialize = cadence(function (async, conf) {\n\n    async(function () {\n\n        db.connect(async())                     // <- connect to database.\n        fs.readFile(conf, 'utf8', async())      // <- *and* slurp configuration.\n\n    }, function (conn, conf) {                  // <- initialize the connection\n                                                //    with the configuration.\n        conf = JSON.parse(conf)\n\n        conn.encoding = conf.encoding || 'UTF-8'\n        conn.lang = conf.lang || 'en_US'\n\n        return conn\n\n    })\n})\n```\n\n### Breaking, Leaving a Cadence Early\n\nYou can leave a **cadence** by returning an array of arguments, the first\nargument being the `async.break` property.\n\n```javascript\nvar early = cadence(function (async) {\n    async(function () {\n\n        return [ async.break, 2 ]   // <- the `async` means break.\n\n    }, function () {\n\n        echo(1, value())            // <- never called.\n\n    })\n})\n```\n\nYou will use this construct all the time to end loops. You will also use it to\nreturn early when you catch an exception.\n\nThe following is example of returing cached asynchronous operation early.\n\nI've said that asynchronous trumps synchronous, but `return` trumps anything\nthat follows it. That is why `return` makes for a nice break construct.\n\n```javascript\nvar fs = require('fs'), cadence = require('cadence'), config\n\nmodule.exports = cadence(function (async) {\n\n    async(function () {\n\n        if (config) return [ async.break, config ]\n\n        fs.readFile('./config.json', 'utf8', step())\n\n    }, function (body) {\n\n        return [ config = JSON.parse(body) ]\n\n    })\n\n})\n```\n\n### Forever Loops\n\nA loop is a **cadence** that repeats itself. When we create a **cadence**, the\n`async` function returns a loop function that we can use to invoke the\n**cadence** as a loop.\n\nBy convention, we call this loop function immediately.\n\nThis is an endless loop. In order to leave the loop we need to break from the\n**cadence**.\n\n```javascript\nvar loopy = cadence(function (async) {\n\n    var count = 0\n\n    async(function () {\n\n        if (count == 10) {\n            return [ async.break, count ]   // <- break and return count.\n        } else {\n            count++\n        }\n\n    })()\n   // ^^ loop forever.\n})\n\nloopy(function (error, value) {\n\n    assert(value, 10, 'looped')\n\n})\n```\n\n### Loop Arguments\n\nYou can pass arguments into a loop by passing them to the loop constructor.\n\nOn subsequent iterations the arguments after the index argument are the results\nof the previous iteration, the previous invocation of the **cadence**.\n\n```javascript\nvar reduce = cadence(function (async) {\n\n    var index = 0\n    async(function (sum) {\n                 // ^^^ initial argument or result of last iteration.\n\n        if [ index == 5 ] return [ async.break, sum ]\n        else return sum + index++\n\n    })(0)\n    // ^ initial argument.\n})\n\nreduce(function (error, value) {\n\n    assert(value, 10, 'reduced sum')\n\n})\n```\n\n### For Each Loops\n\nYou can create for each loops using `cadence.forEach`. The `cadence.forEach`\nfunction returns a loop initializer function. You call it with an array of items\nto iterate over. Iteration is serial, one item after the next.\n\nThe argument given to the loop body is the value of the current array element\nfollowed by the current index.\n\n```javascript\nvar sum = cadence(function (async) {\n    var sum = 0\n    async.forEach(function (value) {\n        return sum + value\n    })([ 1, 2, 3, 4 ])\n})(function (error, sum) {\n    if (error) throw error\n    assert(sum, 10, 'reduce')\n})\n\nsum(function (error, value) {\n\n    assert(value, 10, 'summed')\n\n})\n```\n\n### Each Loop Index Argument\n\nThe second argument to an each loop **cadence** is the index of the entry in the\narray.\n\n```javascript\nvar sum = cadence(function (async) {\n\n    var sum = 0\n\n    async.forEach(function (number, index) {\n                         // ^^^^^ index of array entry.\n        return sum + (number - index)\n\n    })([ 1, 2, 3 ])\n\n})\n\nsum(function (error, value) {\n\n    assert(value, 3, 'sum of ones')\n\n})\n```\n\n### For Each Loop Additional Arguments\n\nYou can pass arguments to the for each loop **cadence** by passing them in after\nthe each loop array.\n\nThe arguments after the array argument are the arguments passed to the loop\nstarter on the first iteration.\n\nOn subsequent iterations the arguments after the index argument are the results\nof the previous iteration, the previous invocation of the **cadence**.\n\n```javascript\nvar reduce = cadence(function (async) {\n\n    async.forEach(function (number, index, sum) {\n                                        // ^^^ initial argument or result of last iteration.\n        return sum + number\n\n    })([ 1, 2, 3 ], 0)\n                 // ^ initial argument.\n})\n\nreduce(function (error, value) {\n\n    if (error) throw error\n    assert(value, 10, 'reduced sum')\n\n})\n```\n\n### Mapped Loops\n\nYou can perform asynchronous array mapping using `async.map`. The result of the\nmapping is passed  to the next **step**. Just as in `async.forEach`, the first\nargument is the array alue,\n\n```javascript\nvar squares = cadence(function (async) {\n\n    async.map(function (value, index) {\n\n        return value * index\n\n    })([ 1, 2, 3 ], 3)\n    // ^^  ^ gather a counted loop.\n})\n\nsquares(function (error, array) {\n\n    deepEqual(array, [ 0, 2, 6 ], 'mapped')\n\n})\n```\n\n### Loops Nested in Cadences\n\nAll of the above loop examples can be used in any **step** in any **cadence**,\nnot just the function body.\n\nLoops can contain loops.\n\n```\nvar multiply = cadence(function (async, matrix) {\n    async(function () {\n        var i = 0, j = 0\n        async(function () {\n            if (i == matrix.length) return [ async.break ]\n            async(function () {\n                if (j == matrix[i].length) return [ async.break ]\n                echo(matrix[i][j] * 5, async())\n            }, function (value) {\n                matrix[i][j] = value\n                j++\n            })()\n        }, function () {\n            j = 0\n            i++\n        })()\n    }, function () {\n        return [ matrix ]\n    })\n})\n\nmultiply([[ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]], function (error, matrix) {\n    if (error) throw error\n    deepEqual(matrix, [[ 5, 10, 15 ], [ 20, 25, 30 ], [ 35, 40, 45 ]])\n})\n```\n\nThe above is a contrived example that multiples each element in an array of\narrays by five. It is much easier to express using `async.map`.\n\n```\nvar multiply = cadence(function (async, matrix) {\n    async.map(function (array) {\n        async.map(function (value) {\n            echo(value * 5, async())\n        })(array)\n    })(matrix)\n})\n\nmultiply([[ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]], function (error, matrix) {\n    if (error) throw error\n    deepEqual(matrix, [[ 5, 10, 15 ], [ 20, 25, 30 ], [ 35, 40, 45 ]])\n})\n```\n\n### Loop Labels\n\n### What's Missing?\n\n * Quafliied catch blocks.\n * Details of catch, I believe.\n * Finalizers; how to use them, where to use them.\n\n### Accompanying Documents and Apendexes\n\n * The Rules of Cadence\n * Design Decisions\n * Thinking in Cadence ~ Asynchronous Functions, Error-First Callbacks,\n Asynchrnous Returns, Asynchronous Stacks, Turning the Corner.\n * Major Benefit: Errors Up and Out\n * Major Benefit: Trampoline\n\n## The Rules of Cadence\n\nHere is Cadence presented as a set or rules to follow. It acts as both a\nrefernece and a glossary. Ordering is subject to change.\n\nThe first argument to a cadence funtction body is the universal builder function\nasync.\n\nA Cadence function body is a cadence with a single step.\n\nResult of a Cadence function is the result of all cadences and steps in the the\nfunction body.\n\nNotes: Terminating an asynchronous stack.\n",
  "readmeFilename": "README.md",
  "repository": {
    "url": "git://github.com/bigeasy/cadence.git",
    "type": "git"
  },
  "scripts": {
    "test": "proof platform win32 && proof test */*.t.js || t/test"
  },
  "version": "1.0.1"
}
