{
  "_args": [
    [
      {
        "raw": "interrupt@1.x",
        "scope": null,
        "escapedName": "interrupt",
        "name": "interrupt",
        "rawSpec": "1.x",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/jbrown/Sites/10-apps-in-10-weeks/react/react-website/node_modules/eject"
    ]
  ],
  "_from": "interrupt@>=1.0.0 <2.0.0",
  "_id": "interrupt@1.2.0",
  "_inCache": true,
  "_location": "/interrupt",
  "_nodeVersion": "4.4.4",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/interrupt-1.2.0.tgz_1466371487770_0.6635912815108895"
  },
  "_npmUser": {
    "name": "bigeasy",
    "email": "alan@prettyrobots.com"
  },
  "_npmVersion": "2.15.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "interrupt@1.x",
    "scope": null,
    "escapedName": "interrupt",
    "name": "interrupt",
    "rawSpec": "1.x",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/eject"
  ],
  "_resolved": "https://registry.npmjs.org/interrupt/-/interrupt-1.2.0.tgz",
  "_shasum": "8f8e0d0cfba190e74682e82d8f0439205a670209",
  "_shrinkwrap": null,
  "_spec": "interrupt@1.x",
  "_where": "/Users/jbrown/Sites/10-apps-in-10-weeks/react/react-website/node_modules/eject",
  "author": {
    "name": "Alan Gutierrez",
    "email": "alan@prettyrobots.com"
  },
  "bugs": {
    "url": "https://github.com/bigeasy/interrupt/issues"
  },
  "dependencies": {
    "supersede": "1.x"
  },
  "description": "Errors that you can catch by type.",
  "devDependencies": {
    "proof": "1.x"
  },
  "directories": {},
  "dist": {
    "shasum": "8f8e0d0cfba190e74682e82d8f0439205a670209",
    "tarball": "https://registry.npmjs.org/interrupt/-/interrupt-1.2.0.tgz"
  },
  "gitHead": "edeb1b21b9c21c14f878c04513ee72f3a800e573",
  "homepage": "https://github.com/bigeasy/interrupt",
  "keywords": [
    "error",
    "try",
    "catch"
  ],
  "license": "MIT",
  "main": "interrupt",
  "maintainers": [
    {
      "name": "bigeasy",
      "email": "alan@prettyrobots.com"
    }
  ],
  "name": "interrupt",
  "optionalDependencies": {},
  "readme": "[![Build Status](https://travis-ci.org/bigeasy/interrupt.svg)](https://travis-ci.org/bigeasy/interrupt) [![Coverage Status](https://coveralls.io/repos/bigeasy/interrupt/badge.svg?branch=master&service=github)](https://coveralls.io/github/bigeasy/interrupt?branch=master)\n\nErrors that you can catch by type.\n\nInterrupt is part of the [Cadence](https://github.com/bigeasy/cadence) Universe.\nCadence provides a robust asynchronous try/catch mechansism. Thus, I use\ntry/catch error handling in all my evented Node.js programs.\n\nWhen you throw an exception in any other language, you're able to catch those\nexceptions by type, so that you only handle the exceptions you know how to\nhandle.\n\nYou can't catch exceptions by type in JavaScript. The best you can do is check\nthe error message. There is no real way to indicate an exception type that was\nthrown deep within your code.\n\nWith Interrupt you can add namepsaces to your exceptions and catch specific\nexceptions based on namespace and by matching the message.\n\n### Synopsis\n\n```javascript\nvar assert = require('assert')\nvar interrupt = require('interrupt').createIterruptor('bigeasy.example')\n\ntry {\n    throw interrupt(new Error('convert'), { value: 1 })\n}  catch (error) {\n    interrupt.rescue('bigeasy.example.convert', function () {\n        assert.equal(error.value, 1)\n    })(error)\n}\n```\n\nIn the above example we create an `interrupt` instance to use in our module\nproviding a namespace that will be used to distinquish our errors. The naming\nconvention for interrupt is your GitHub name and the name of the project.\n\nWe create a new exception by calling `interrupt`, passing a `new Error` with a\nmessage that is used to distinguish the error. You can also provide a map of\nproperties that will be added to the error for context.\n\nIn the catch block we call `interrupt.rescue()` with a pattern to match the\nspecific exception. The pattern will match the combination of the `interrupt`\nnamespace and exception message. If the pattern matches, then the exception is\ncaught. If it does not match, the exception is rethrown.\n\n### Unambiguous Exceptions\n\nWhat if you want to catch an exception from a third party library. You use a\ntry/catch block to choke up on the point of failure and wrap the result in an\ninterupt.\n\n```javascript\nvar assert = require('assert')\nvar interrupt = require('interrupt').createIterruptor('bigeasy.example')\n\ntry {\n    try {\n        library.frobinate(1)\n    } catch (error) {\n        // almost certainly a frobination exception.\n        throw interrupt(new Error('frobinate'), { cause: error })\n    }\n    library.doManyOtherThings()\n} catch (error) {\n    interrupt.rescue('bigeasy.example.frobinate', function (error) {\n        console.log('frobination failure')\n        console.log(error.cause.stack)\n    })(error)\n}\n```\n\nIn the above example we've put a catch block around the operation we know might\nfail, that we know how to recover from, but rather than try and guess the error\nin some remove catch block when it has unwound the stack, we immediately wrap it\nin using `interrupt`. The `rescue` function will only catch Interrupt\nexceptions, it will rethrow all others.\n\nIn my programs, I find that the two patterns above make try catch useful again.\n\n### Selecting Exceptions\n\n```javascript\nvar assert = require('assert')\nvar interrupt = require('interrupt').createIterruptor('bigeasy.example')\n\ntry {\n    if (!library.frobinate(1)) {\n        throw interrupt(new Error('forbinate', { frobination: 1 })\n    }\n    if (!library.reticulate()) {\n        throw interrupt(new Error('reticuate'))\n    }\n} catch (error) {\n    interrupt.rescue([\n        'bigeasy.example.frobinate', function (error) {\n            console.log('frobination failure: ' + error.frobination)\n        },\n        'bigeasy.example.reticulate', function () {\n            console.log('reticuation failure')\n        },\n        'bigeasy.example', function () {\n            console.log('other library failure')\n        }\n    ])(error)\n}\n```\n\n### With Cadence\n\nWhen combine with Cadence, I have robuts asynchronous try/catch with unambiguous\nerror handling.\n\n```javascript\nfunction Service (processor) {\n    this._processor = processor\n}\n\nService.prototype.serve = cadence(function (async, file) {\n    async([function () {\n        async([function () {\n            fs.readFile(file, 'utf8', async())\n        }, function (error) {\n            throw interrupt(new Error('readFile'), { cause: error, file: file })\n        }], function (file) {\n            this._processor.process(file, async())\n        })\n    }, function (error) {\n        interrupt.rescue('bigeasy.serivce.readFile', function (error) {\n            console.log('cannot read file: ' + error.file)\n        })(error)\n    }])\n})\n```\n\nThe above example shows how we can catch an error locally, then wrap it so that\nwe know to catch it in the outer most rescue loop. In this example, it would be\nbetter to log and return, but imagine if you will a much more complicated\nexample where the file read is nested deeply in the call stack.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/bigeasy/interrupt.git"
  },
  "scripts": {
    "test": "proof platform win32 && proof test */*.t.js || t/test"
  },
  "version": "1.2.0"
}
